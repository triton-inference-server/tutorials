import datetime
import json
import re
from typing import Dict, List, Literal, Optional

import pandas as pd
import yaml
import yfinance as yf
from pydantic import BaseModel


class FunctionCall(BaseModel):
    arguments: dict
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: str
    """The name of the function to call."""


class FunctionDefinition(BaseModel):
    name: str
    description: Optional[str] = None
    parameters: Optional[Dict[str, object]] = None


class FunctionSignature(BaseModel):
    function: FunctionDefinition
    type: Literal["function"]


class PromptSchema(BaseModel):
    Role: str
    Objective: str
    Tools: str
    Schema: str
    Instructions: str


def read_yaml_file(file_path: str) -> PromptSchema:
    with open(file_path, "r") as file:
        yaml_content = yaml.safe_load(file)

    prompt_schema = PromptSchema(
        Role=yaml_content.get("Role", ""),
        Objective=yaml_content.get("Objective", ""),
        Tools=yaml_content.get("Tools", ""),
        Schema=yaml_content.get("Schema", ""),
        Instructions=yaml_content.get("Instructions", ""),
    )
    return prompt_schema


def format_yaml_prompt(prompt_schema: PromptSchema, variables: Dict) -> str:
    formatted_prompt = ""
    for field, value in prompt_schema.model_dump().items():
        formatted_value = value.format(**variables)
        if field == "Instructions":
            formatted_prompt += f"{formatted_value}"
        else:
            formatted_value = formatted_value.replace("\n", " ")
            formatted_prompt += f"{formatted_value}"
    return formatted_prompt


TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "get_current_stock_price",
            "description": "Get the current stock price for a given symbol.\n\nArgs:\n  symbol (str): The stock symbol.\n\nReturns:\n  float: The current stock price, or None if an error occurs.",
            "parameters": {
                "type": "object",
                "properties": {"symbol": {"type": "string"}},
                "required": ["symbol"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "get_company_news",
            "description": "Get company news and press releases for a given stock symbol.\n\nArgs:\nsymbol (str): The stock symbol.\n\nReturns:\npd.DataFrame: DataFrame containing company news and press releases.",
            "parameters": {
                "type": "object",
                "properties": {"symbol": {"type": "string"}},
                "required": ["symbol"],
            },
        },
    },
]


def process_prompt(original_prompt):
    prompt_schema = read_yaml_file("./sys_prompt.yml")
    schema_json = FunctionCall.model_json_schema()
    variables = {"date": datetime.date.today(), "tools": TOOLS, "schema": schema_json}
    sys_prompt = format_yaml_prompt(prompt_schema, variables)
    processed_prompt = f"<|im_start|>system\n {sys_prompt}<|im_end|>\n"
    processed_prompt += f"<|im_start|>user\n {original_prompt}\nThis is the first turn and you don't have <tool_results> to analyze yet. <|im_end|>\n <|im_start|>assistant"
    return processed_prompt


class MyFunctions:
    def get_company_news(self, symbol: str) -> pd.DataFrame:
        """
        Get company news and press releases for a given stock symbol.

        Args:
        symbol (str): The stock symbol.

        Returns:
        pd.DataFrame: DataFrame containing company news and press releases.
        """
        try:
            news = yf.Ticker(symbol).news
            return news
        except Exception as e:
            print(f"Error fetching company news for {symbol}: {e}")
            return pd.DataFrame()

    def get_current_stock_price(self, symbol: str) -> float:
        """
        Get the current stock price for a given symbol.

        Args:
            symbol (str): The stock symbol.

        Returns:
            float: The current stock price, or None if an error occurs.
        """
        try:
            stock = yf.Ticker(symbol)
            # Use "regularMarketPrice" for regular market hours, or "currentPrice" for pre/post market
            current_price = stock.info.get(
                "regularMarketPrice", stock.info.get("currentPrice")
            )
            return current_price if current_price else None
        except Exception as e:
            print(f"Error fetching current price for {symbol}: {e}")
            return None
